name: Refresh GA4 (daily + manual)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "15 7 * * *"  # daily 07:15 UTC

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      GA4_PROPERTY_ID: ${{ secrets.GA4_PROPERTY_ID }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json
        run: |
          test -f package.json || npm init -y
          npm pkg set type=commonjs

      - name: Install deps
        run: npm i --no-fund --no-audit @google-analytics/data@^5.0.4

      - name: Decode GCP service account key
        run: |
          mkdir -p .secrets
          echo '${{ secrets.GCP_SA_JSON }}' | base64 -d > .secrets/gcp.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$PWD/.secrets/gcp.json" >> $GITHUB_ENV

      - name: Build GA4 JSON (Washington Examiner)
        run: |
          mkdir -p scripts data
          cat > scripts/fetch_ga4.cjs <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { BetaAnalyticsDataClient } = require("@google-analytics/data");

          const propertyId = process.env.GA4_PROPERTY_ID;
          if (!propertyId) throw new Error("Missing GA4_PROPERTY_ID");
          const client = new BetaAnalyticsDataClient();

          const pad = n => String(n).padStart(2,"0");
          const ymd = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
          const yyyymmdd = d => `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}`;

          const now = new Date();
          const end = new Date(now); end.setDate(end.getDate()-1);
          const start = new Date(end); start.setDate(start.getDate()-6);

          const startISO = ymd(start);
          const endISO = ymd(end);
          const property = `properties/${propertyId}`;

          console.log(`[GA4] ${startISO} → ${endISO}`);

          async function runReport(config) {
            const [res] = await client.runReport({
              property,
              dateRanges: [{ startDate: startISO, endDate: endISO }],
              ...config
            });
            return res;
          }

          // KPIs
          async function getDailyKPIs() {
            console.log('[KPI] Fetching...');
            const r = await runReport({
              dimensions: [{ name: "date" }],
              metrics: [
                { name: "totalUsers" },
                { name: "newUsers" },
                { name: "screenPageViews" },
                { name: "sessions" },
                { name: "bounceRate" },
                { name: "averageSessionDuration" }
              ]
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const m = row.metricValues;
              map[date] = {
                date,
                totalUsers: parseInt(m[0].value),
                newUsers: parseInt(m[1].value),
                pageviews: parseInt(m[2].value),
                sessions: parseInt(m[3].value),
                bounceRate: parseFloat(m[4].value),
                averageSessionDuration: parseFloat(m[5].value)
              };
            }
            console.log(`[KPI] ${Object.keys(map).length} days`);
            return map;
          }

          // Referrers
          async function getReferrers() {
            console.log('[REF] Fetching...');
            const r = await runReport({
              dimensions: [{ name: "date" }, { name: "firstUserSource" }],
              metrics: [{ name: "totalUsers" }],
              orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
              limit: 1000
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const source = row.dimensionValues[1].value;
              const users = parseInt(row.metricValues[0].value);
              
              if (!map[date]) map[date] = [];
              map[date].push({ source, users });
            }

            for (const date of Object.keys(map)) {
              map[date] = map[date].slice(0, 15); // Keep top 15
            }
            
            console.log(`[REF] ${Object.keys(map).length} days`);
            return map;
          }

          // Authors - Washington Examiner specific
          async function getAuthors() {
            console.log('[AUTH] Trying Washington Examiner parameters...');
            
            // Your exact GA4 custom parameters
            const wexParams = ['authors', 'authorName', 'authorDesignation'];
            
            for (const param of wexParams) {
              console.log(`[AUTH] Testing customEvent:${param}...`);
              
              try {
                const r = await runReport({
                  dimensions: [{ name: "date" }, { name: `customEvent:${param}` }],
                  metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                  orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                  limit: 1000
                });

                const map = {};
                let validRows = 0;

                for (const row of r.rows || []) {
                  const date = row.dimensionValues[0].value;
                  const author = row.dimensionValues[1].value;
                  const users = parseInt(row.metricValues[0].value);
                  const views = parseInt(row.metricValues[1].value);

                  // Skip empty/invalid values
                  if (!author || author === "(not set)" || author === "null" || 
                      author === "undefined" || author === "" || users === 0) {
                    continue;
                  }

                  if (!map[date]) map[date] = [];
                  map[date].push({ author, users, views });
                  validRows++;
                }

                // Sort and limit
                for (const date of Object.keys(map)) {
                  map[date].sort((a, b) => b.users - a.users);
                  map[date] = map[date].slice(0, 10);
                }

                console.log(`[AUTH] ${param}: ${validRows} valid entries, ${Object.keys(map).length} days`);
                
                if (validRows > 0) {
                  // Show sample data
                  const samples = Object.values(map).flat().slice(0, 3);
                  console.log(`[AUTH] Sample: ${samples.map(s => s.author).join(', ')}`);
                  return map;
                }

              } catch (error) {
                console.log(`[AUTH] ${param} error: ${error.message}`);
              }
            }

            // Fallback: Try page title parsing
            console.log('[AUTH] Trying page title extraction...');
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "pageTitle" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 2000
              });

              const map = {};
              let extracted = 0;

              const authorPatterns = [
                /By\s+([A-Za-z\s]+?)(?:\s*\||$)/i,
                /Author:\s*([A-Za-z\s]+?)(?:\s*\||$)/i,
                /Written by\s+([A-Za-z\s]+?)(?:\s*\||$)/i,
                /-\s*([A-Za-z\s]{4,25})\s*$/i
              ];

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const title = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                let author = null;
                for (const pattern of authorPatterns) {
                  const match = title.match(pattern);
                  if (match) {
                    author = match[1].trim();
                    if (author.length > 3 && author.length < 30) {
                      break;
                    }
                    author = null;
                  }
                }

                if (author) {
                  if (!map[date]) map[date] = {};
                  if (!map[date][author]) {
                    map[date][author] = { author, users: 0, views: 0 };
                  }
                  map[date][author].users += users;
                  map[date][author].views += views;
                  extracted++;
                }
              }

              // Convert to array format
              const finalMap = {};
              for (const [date, authors] of Object.entries(map)) {
                finalMap[date] = Object.values(authors)
                  .sort((a, b) => b.users - a.users)
                  .slice(0, 10);
              }

              console.log(`[AUTH] Page title extraction: ${extracted} entries, ${Object.keys(finalMap).length} days`);
              
              if (extracted > 0) {
                const samples = Object.values(finalMap).flat().slice(0, 3);
                console.log(`[AUTH] Extracted: ${samples.map(s => s.author).join(', ')}`);
                return finalMap;
              }

            } catch (error) {
              console.log(`[AUTH] Page title error: ${error.message}`);
            }

            console.log('[AUTH] No author data found with any method');
            return {};
          }

          (async () => {
            try {
              const [kpis, referrers, authors] = await Promise.all([
                getDailyKPIs(),
                getReferrers(),
                getAuthors()
              ]);

              const rows = [];
              for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                const dateKey = yyyymmdd(d);
                const dayData = {
                  date: dateKey,
                  totalUsers: kpis[dateKey]?.totalUsers || 0,
                  newUsers: kpis[dateKey]?.newUsers || 0,
                  pageviews: kpis[dateKey]?.pageviews || 0,
                  sessions: kpis[dateKey]?.sessions || 0,
                  bounceRate: kpis[dateKey]?.bounceRate || 0,
                  averageSessionDuration: kpis[dateKey]?.averageSessionDuration || 0,
                  referrers: referrers[dateKey] || [],
                  authors: authors[dateKey] || []
                };
                rows.push(dayData);
              }

              const totalAuthorEntries = rows.reduce((sum, row) => sum + row.authors.length, 0);
              const uniqueAuthors = new Set();
              rows.forEach(row => row.authors.forEach(a => uniqueAuthors.add(a.author)));

              const output = {
                updatedAt: new Date().toISOString(),
                range: { start: startISO, end: endISO },
                rows,
                meta: {
                  totalDays: rows.length,
                  totalAuthorEntries,
                  uniqueAuthors: uniqueAuthors.size,
                  sampleAuthors: Array.from(uniqueAuthors).slice(0, 5)
                }
              };

              fs.writeFileSync(path.join("data", "ga4.json"), JSON.stringify(output, null, 2));
              console.log(`✅ Wrote data/ga4.json - ${rows.length} days, ${totalAuthorEntries} author entries`);

            } catch (error) {
              console.error('❌ Error:', error);
              process.exit(1);
            }
          })();
          NODE
          
          node scripts/fetch_ga4.cjs

      - name: Commit updated data
        run: |
          if git status --porcelain | grep -E '^( M|??) data/ga4.json'; then
            git config user.name "github-actions"
            git config user.email "actions@github.com"
            git add data/ga4.json
            git commit -m "data: refresh ga4.json ($(date '+%Y-%m-%d %H:%M'))"
            git push
          else
            echo "No changes to commit."
          fi
