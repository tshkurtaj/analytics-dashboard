name: Refresh GA4 (daily + manual)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "15 7 * * *"  # daily 07:15 UTC

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      GA4_PROPERTY_ID: ${{ secrets.GA4_PROPERTY_ID }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json
        run: |
          test -f package.json || npm init -y
          npm pkg set type=commonjs

      - name: Install deps
        run: npm i --no-fund --no-audit @google-analytics/data@^5.0.4

      - name: Decode GCP service account key
        run: |
          mkdir -p .secrets
          echo '${{ secrets.GCP_SA_JSON }}' | base64 -d > .secrets/gcp.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$PWD/.secrets/gcp.json" >> $GITHUB_ENV

      - name: Build GA4 JSON (Washington Examiner - Fixed)
        run: |
          mkdir -p scripts data
          cat > scripts/fetch_ga4.cjs <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { BetaAnalyticsDataClient } = require("@google-analytics/data");

          const propertyId = process.env.GA4_PROPERTY_ID;
          if (!propertyId) throw new Error("Missing GA4_PROPERTY_ID");
          const client = new BetaAnalyticsDataClient();

          const pad = n => String(n).padStart(2,"0");
          const ymd = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
          const yyyymmdd = d => `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}`;

          const now = new Date();
          const end = new Date(now); end.setDate(end.getDate()-1);
          const start = new Date(end); start.setDate(start.getDate()-6);

          const startISO = ymd(start);
          const endISO = ymd(end);
          const property = `properties/${propertyId}`;

          console.log(`[GA4] Fetching ${startISO} ‚Üí ${endISO}`);

          async function runReport(config) {
            const [res] = await client.runReport({
              property,
              dateRanges: [{ startDate: startISO, endDate: endISO }],
              ...config
            });
            return res;
          }

          // KPIs
          async function getDailyKPIs() {
            console.log('[KPI] Fetching daily KPIs...');
            const r = await runReport({
              dimensions: [{ name: "date" }],
              metrics: [
                { name: "totalUsers" },
                { name: "newUsers" },
                { name: "screenPageViews" },
                { name: "sessions" },
                { name: "bounceRate" },
                { name: "averageSessionDuration" }
              ]
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const m = row.metricValues;
              map[date] = {
                date,
                totalUsers: parseInt(m[0].value),
                newUsers: parseInt(m[1].value),
                pageviews: parseInt(m[2].value),
                sessions: parseInt(m[3].value),
                bounceRate: parseFloat(m[4].value),
                averageSessionDuration: parseFloat(m[5].value)
              };
            }
            console.log(`[KPI] Found ${Object.keys(map).length} days`);
            return map;
          }

          // Referrers
          async function getReferrers() {
            console.log('[REF] Fetching referrers...');
            const r = await runReport({
              dimensions: [{ name: "date" }, { name: "firstUserSource" }],
              metrics: [{ name: "totalUsers" }],
              orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
              limit: 2000
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const source = row.dimensionValues[1].value;
              const users = parseInt(row.metricValues[0].value);
              
              if (!map[date]) map[date] = [];
              map[date].push({ source, users });
            }

            // Keep top 15 per day
            for (const date of Object.keys(map)) {
              map[date] = map[date].slice(0, 15);
            }
            
            console.log(`[REF] Found ${Object.keys(map).length} days`);
            return map;
          }

          // Authors - The working version!
          async function getAuthors() {
            console.log('[AUTH] Fetching author data using customEvent:authors...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "customEvent:authors" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 5000
              });

              const map = {};
              let validEntries = 0;

              console.log(`[AUTH] Processing ${r.rows?.length || 0} raw rows...`);

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const author = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                // Skip invalid entries
                if (!author || author === "(not set)" || author === "null" || 
                    author === "undefined" || author.trim() === "" || users === 0) {
                  continue;
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  author: author.trim(), 
                  users: users.toString(), 
                  views: views.toString() 
                });
                validEntries++;
              }

              // Sort and limit to top 10 per day
              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 10);
              }

              console.log(`[AUTH] Success! ${validEntries} valid entries across ${Object.keys(map).length} days`);
              
              // Show sample data
              const allAuthors = Object.values(map).flat();
              if (allAuthors.length > 0) {
                const samples = allAuthors.slice(0, 5).map(a => `${a.author} (${a.users})`);
                console.log(`[AUTH] Sample: ${samples.join(', ')}`);
              }
              
              return map;

            } catch (error) {
              console.log(`[AUTH] Error: ${error.message}`);
              return {};
            }
          }

          async function main() {
            try {
              const [kpis, referrers, authors] = await Promise.all([
                getDailyKPIs(),
                getReferrers(),
                getAuthors()
              ]);

              // Build final data structure
              const rows = [];
              for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                const dateKey = yyyymmdd(d);
                
                const dayData = {
                  date: dateKey,
                  totalUsers: kpis[dateKey]?.totalUsers || 0,
                  newUsers: kpis[dateKey]?.newUsers || 0,
                  pageviews: kpis[dateKey]?.pageviews || 0,
                  sessions: kpis[dateKey]?.sessions || 0,
                  bounceRate: kpis[dateKey]?.bounceRate || 0,
                  averageSessionDuration: kpis[dateKey]?.averageSessionDuration || 0,
                  referrers: referrers[dateKey] || [],
                  authors: authors[dateKey] || []
                };
                
                rows.push(dayData);
              }

              // Calculate summary stats
              const totalAuthorEntries = rows.reduce((sum, row) => sum + row.authors.length, 0);
              const uniqueAuthors = new Set();
              rows.forEach(row => row.authors.forEach(a => uniqueAuthors.add(a.author)));

              const output = {
                updatedAt: new Date().toISOString(),
                range: { start: startISO, end: endISO },
                rows,
                meta: {
                  totalDays: rows.length,
                  totalAuthorEntries,
                  uniqueAuthors: uniqueAuthors.size,
                  sampleAuthors: Array.from(uniqueAuthors).slice(0, 8)
                }
              };

              // Write file
              fs.writeFileSync(path.join("data", "ga4.json"), JSON.stringify(output, null, 2));
              
              console.log(`‚úÖ SUCCESS! Wrote data/ga4.json`);
              console.log(`üìä ${rows.length} days, ${totalAuthorEntries} author entries, ${uniqueAuthors.size} unique authors`);
              
              if (uniqueAuthors.size > 0) {
                console.log(`üìù Top authors: ${Array.from(uniqueAuthors).slice(0, 5).join(', ')}`);
              }

            } catch (error) {
              console.error('‚ùå Fatal error:', error);
              process.exit(1);
            }
          }

          main();
          NODE
          
          node scripts/fetch_ga4.cjs

      - name: Commit updated data
        run: |
          if git status --porcelain | grep -E '^( M|??) data/ga4.json'; then
            git config user.name "github-actions"
            git config user.email "actions@github.com"
            git add data/ga4.json
            git commit -m "data: refresh ga4.json with authors ($(date '+%Y-%m-%d %H:%M'))"
            git push
          else
            echo "No changes to commit."
          fi
