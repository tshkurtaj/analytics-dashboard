// Washington Examiner Analytics Dashboard Worker - Complete Version
export default {
  async fetch(request, env, ctx) {
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405, headers: corsHeaders });
    }

    try {
      const { message } = await request.json();
      
      const dataUrl = 'https://raw.githubusercontent.com/tshkurtaj/analytics-dashboard/main/data/ga4.json';
      const dataResponse = await fetch(dataUrl, {
        headers: {
          'User-Agent': 'WashingtonExaminer-Analytics-Bot/1.0',
          'Cache-Control': 'no-cache'
        }
      });
      
      if (!dataResponse.ok) {
        throw new Error(`Failed to fetch analytics data: ${dataResponse.status}`);
      }
      
      const data = await dataResponse.json();
      const response = await processWEXQuery(message, data);
      
      return new Response(JSON.stringify({ response }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
      
    } catch (error) {
      console.error('Analytics Worker error:', error);
      return new Response(JSON.stringify({ 
        response: `I'm having trouble accessing the analytics data. Error: ${error.message}` 
      }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
};

async function processWEXQuery(query, data) {
  const queryLower = query.toLowerCase();
  
  if (!data.rows || data.rows.length === 0) {
    return "No analytics data available.";
  }
  
  const latestData = data.rows[data.rows.length - 1];
  const allData = data.rows;
  
  // Article/Story queries
  if (queryLower.includes('article') || queryLower.includes('story') || 
      queryLower.includes('stories') || queryLower.includes('content')) {
    return handleArticleQueries(queryLower, allData, latestData);
  }
  
  // Section queries
  if (queryLower.includes('section') || queryLower.includes('category') || 
      queryLower.includes('topic')) {
    return handleSectionQueries(queryLower, allData, latestData);
  }
  
  // Author queries
  if (queryLower.includes('author') || queryLower.includes('writer') || 
      queryLower.includes('asher') || queryLower.includes('jenny') || 
      queryLower.includes('molly') || queryLower.includes('lauren')) {
    return handleAuthorQueries(queryLower, allData, latestData);
  }
  
  // KPI queries
  if (queryLower.includes('kpi') || queryLower.includes('yesterday') || 
      queryLower.includes('metrics') || queryLower.includes('performance')) {
    return handleKPIQueries(queryLower, latestData, allData);
  }
  
  // Traffic queries
  if (queryLower.includes('referrer') || queryLower.includes('traffic') || 
      queryLower.includes('source')) {
    return handleTrafficQueries(queryLower, latestData, allData);
  }
  
  // Trend queries
  if (queryLower.includes('trend') || queryLower.includes('week') || 
      queryLower.includes('daily') || queryLower.includes('compare')) {
    return handleTrendQueries(queryLower, allData);
  }
  
  return handleOverviewQuery(latestData, allData, data);
}

function handleArticleQueries(query, allData, latestData) {
  const hasArticleData = allData.some(day => day.articles && day.articles.length > 0);
  if (!hasArticleData) {
    return "No article performance data available. This might indicate that article tracking needs to be configured in GA4.";
  }
  
  // Yesterday's top articles
  if (query.includes('yesterday') || query.includes('today')) {
    return getYesterdayArticles(latestData);
  }
  
  // Top performing articles over time
  if (query.includes('top') || query.includes('best') || query.includes('performing')) {
    return getTopArticles(allData);
  }
  
  return getArticleOverview(allData, latestData);
}

function getYesterdayArticles(latestData) {
  if (!latestData.articles || latestData.articles.length === 0) {
    return "No article performance data available for yesterday.";
  }
  
  const date = latestData.date;
  const formattedDate = `${date.slice(4,6)}/${date.slice(6,8)}/${date.slice(0,4)}`;
  
  let response = `ğŸ“° **Top Articles Yesterday** (${formattedDate})\n\n`;
  
  latestData.articles.slice(0, 10).forEach((article, index) => {
    const users = parseInt(article.users) || 0;
    const views = parseInt(article.views) || 0;
    response += `${index + 1}. **${article.title}**\n`;
    response += `   ğŸ‘¥ ${users.toLocaleString()} users\n`;
    response += `   ğŸ“„ ${views.toLocaleString()} views\n\n`;
  });
  
  return response;
}

function getTopArticles(allData) {
  const articleAggregates = {};
  
  for (const day of allData) {
    if (!day.articles) continue;
    
    for (const article of day.articles) {
      if (!articleAggregates[article.title]) {
        articleAggregates[article.title] = {
          title: article.title,
          totalUsers: 0,
          totalViews: 0,
          appearances: 0
        };
      }
      
      articleAggregates[article.title].totalUsers += parseInt(article.users) || 0;
      articleAggregates[article.title].totalViews += parseInt(article.views) || 0;
      articleAggregates[article.title].appearances += 1;
    }
  }
  
  const topArticles = Object.values(articleAggregates)
    .sort((a, b) => b.totalUsers - a.totalUsers)
    .slice(0, 8);
  
  if (topArticles.length === 0) {
    return "No article performance data found.";
  }
  
  let response = `ğŸ† **Top Performing Articles** (7-day period)\n\n`;
  
  topArticles.forEach((article, index) => {
    response += `${index + 1}. **${article.title}**\n`;
    response += `   ğŸ‘¥ ${article.totalUsers.toLocaleString()} total users\n`;
    response += `   ğŸ“„ ${article.totalViews.toLocaleString()} total views\n\n`;
  });
  
  return response;
}

function getArticleOverview(allData, latestData) {
  const totalArticleEntries = allData.reduce((sum, day) => sum + (day.articles?.length || 0), 0);
  
  let response = `ğŸ“° **Article Performance Overview**\n\n`;
  response += `ğŸ“Š **Stats:**\n`;
  response += `â€¢ Total article entries: ${totalArticleEntries}\n`;
  response += `â€¢ Data period: ${allData.length} days\n\n`;
  
  if (latestData.articles && latestData.articles.length > 0) {
    response += `ğŸ“… **Yesterday's Top 3 Articles:**\n`;
    latestData.articles.slice(0, 3).forEach((article, i) => {
      const title = article.title.length > 60 ? article.title.substring(0, 57) + "..." : article.title;
      response += `${i + 1}. ${title} - ${parseInt(article.users).toLocaleString()} users\n`;
    });
  }
  
  return response;
}

function handleSectionQueries(query, allData, latestData) {
  const hasSectionData = allData.some(day => day.sections && day.sections.length > 0);
  if (!hasSectionData) {
    return "No section performance data available. This might indicate that section tracking needs to be configured.";
  }
  
  // Yesterday's section performance
  if (query.includes('yesterday') || query.includes('today')) {
    return getYesterdaySections(latestData);
  }
  
  // Top sections over time
  if (query.includes('top') || query.includes('best') || query.includes('performing')) {
    return getTopSections(allData);
  }
  
  return getSectionOverview(allData, latestData);
}

function getYesterdaySections(latestData) {
  if (!latestData.sections || latestData.sections.length === 0) {
    return "No section performance data available for yesterday.";
  }
  
  const date = latestData.date;
  const formattedDate = `${date.slice(4,6)}/${date.slice(6,8)}/${date.slice(0,4)}`;
  
  let response = `ğŸ“ **Top Sections Yesterday** (${formattedDate})\n\n`;
  
  latestData.sections.forEach((section, index) => {
    const users = parseInt(section.users) || 0;
    const views = parseInt(section.views) || 0;
    response += `${index + 1}. **${section.section}**\n`;
    response += `   ğŸ‘¥ ${users.toLocaleString()} users\n`;
    response += `   ğŸ“„ ${views.toLocaleString()} views\n\n`;
  });
  
  return response;
}

function getTopSections(allData) {
  const sectionAggregates = {};
  
  for (const day of allData) {
    if (!day.sections) continue;
    
    for (const section of day.sections) {
      if (!sectionAggregates[section.section]) {
        sectionAggregates[section.section] = {
          name: section.section,
          totalUsers: 0,
          totalViews: 0,
          appearances: 0
        };
      }
      
      sectionAggregates[section.section].totalUsers += parseInt(section.users) || 0;
      sectionAggregates[section.section].totalViews += parseInt(section.views) || 0;
      sectionAggregates[section.section].appearances += 1;
    }
  }
  
  const topSections = Object.values(sectionAggregates)
    .sort((a, b) => b.totalUsers - a.totalUsers)
    .slice(0, 8);
  
  if (topSections.length === 0) {
    return "No section performance data found.";
  }
  
  let response = `ğŸ† **Top Performing Sections** (7-day period)\n\n`;
  
  topSections.forEach((section, index) => {
    const avgDaily = Math.round(section.totalUsers / section.appearances);
    response += `${index + 1}. **${section.name}**\n`;
    response += `   ğŸ‘¥ ${section.totalUsers.toLocaleString()} total users\n`;
    response += `   ğŸ“„ ${section.totalViews.toLocaleString()} total views\n`;
    response += `   ğŸ“… Active ${section.appearances}/7 days (${avgDaily.toLocaleString()} avg/day)\n\n`;
  });
  
  return response;
}

function getSectionOverview(allData, latestData) {
  const uniqueSections = new Set();
  let totalSectionEntries = 0;
  
  for (const day of allData) {
    if (day.sections) {
      totalSectionEntries += day.sections.length;
      day.sections.forEach(section => uniqueSections.add(section.section));
    }
  }
  
  let response = `ğŸ“ **Section Performance Overview**\n\n`;
  response += `ğŸ“Š **Stats:**\n`;
  response += `â€¢ Unique sections tracked: ${uniqueSections.size}\n`;
  response += `â€¢ Total section entries: ${totalSectionEntries}\n`;
  response += `â€¢ Data period: ${allData.length} days\n\n`;
  
  if (latestData.sections && latestData.sections.length > 0) {
    response += `ğŸ“… **Yesterday's Top 3 Sections:**\n`;
    latestData.sections.slice(0, 3).forEach((section, i) => {
      response += `${i + 1}. ${section.section} - ${parseInt(section.users).toLocaleString()} users\n`;
    });
  }
  
  return response;
}

function handleAuthorQueries(query, allData, latestData) {
  const hasAuthorData = allData.some(day => day.authors && day.authors.length > 0);
  if (!hasAuthorData) {
    return "No author performance data available.";
  }
  
  const authorNames = ['asher', 'jenny', 'molly', 'lauren', 'ross'];
  const mentionedAuthor = authorNames.find(name => query.includes(name));
  
  if (mentionedAuthor) {
    return getSpecificAuthorData(mentionedAuthor, allData);
  }
  
  if (query.includes('yesterday') || query.includes('today')) {
    return getYesterdayAuthors(latestData);
  }
  
  if (query.includes('top') || query.includes('best')) {
    return getTopAuthors(allData);
  }
  
  return getAuthorOverview(allData, latestData);
}

function getSpecificAuthorData(authorName, allData) {
  const authorMap = {};
  let fullName = '';
  
  for (const day of allData) {
    if (!day.authors) continue;
    
    for (const author of day.authors) {
      const name = author.author.toLowerCase();
      if (name.includes(authorName)) {
        fullName = author.author;
        if (!authorMap[day.date]) {
          authorMap[day.date] = {
            users: parseInt(author.users) || 0,
            views: parseInt(author.views) || 0
          };
        }
      }
    }
  }
  
  if (Object.keys(authorMap).length === 0) {
    return `No recent data found for any author matching "${authorName}".`;
  }
  
  const dates = Object.keys(authorMap).sort();
  const totalUsers = Object.values(authorMap).reduce((sum, day) => sum + day.users, 0);
  const totalViews = Object.values(authorMap).reduce((sum, day) => sum + day.views, 0);
  
  let response = `ğŸ“ **${fullName}** - Performance Report\n\n`;
  response += `ğŸ“Š **7-Day Summary:**\n`;
  response += `â€¢ Total Users: ${totalUsers.toLocaleString()}\n`;
  response += `â€¢ Total Views: ${totalViews.toLocaleString()}\n`;
  response += `â€¢ Active Days: ${dates.length}/7\n\n`;
  
  response += `ğŸ“… **Recent Performance:**\n`;
  dates.slice(-5).forEach(date => {
    const day = authorMap[date];
    const formattedDate = `${date.slice(4,6)}/${date.slice(6,8)}`;
    response += `${formattedDate}: ${day.users.toLocaleString()} users, ${day.views.toLocaleString()} views\n`;
  });
  
  return response;
}

function getYesterdayAuthors(latestData) {
  if (!latestData.authors || latestData.authors.length === 0) {
    return "No author performance data available for yesterday.";
  }
  
  let response = `ğŸ“ **Top Authors Yesterday**\n\n`;
  
  latestData.authors.slice(0, 8).forEach((author, index) => {
    const users = parseInt(author.users) || 0;
    const views = parseInt(author.views) || 0;
    response += `${index + 1}. **${author.author}**\n`;
    response += `   ğŸ‘¥ ${users.toLocaleString()} users\n`;
    response += `   ğŸ“„ ${views.toLocaleString()} views\n\n`;
  });
  
  return response;
}

function getTopAuthors(allData) {
  const authorAggregates = {};
  
  for (const day of allData) {
    if (!day.authors) continue;
    
    for (const author of day.authors) {
      if (!authorAggregates[author.author]) {
        authorAggregates[author.author] = {
          name: author.author,
          totalUsers: 0,
          totalViews: 0,
          appearances: 0
        };
      }
      
      authorAggregates[author.author].totalUsers += parseInt(author.users) || 0;
      authorAggregates[author.author].totalViews += parseInt(author.views) || 0;
      authorAggregates[author.author].appearances += 1;
    }
  }
  
  const topAuthors = Object.values(authorAggregates)
    .sort((a, b) => b.totalUsers - a.totalUsers)
    .slice(0, 8);
  
  let response = `ğŸ† **Top Performing Authors** (7-day period)\n\n`;
  
  topAuthors.forEach((author, index) => {
    const avgDaily = Math.round(author.totalUsers / author.appearances);
    response += `${index + 1}. **${author.name}**\n`;
    response += `   ğŸ‘¥ ${author.totalUsers.toLocaleString()} total users\n`;
    response += `   ğŸ“„ ${author.totalViews.toLocaleString()} total views\n`;
    response += `   ğŸ“… ${author.appearances}/7 days (${avgDaily.toLocaleString()} avg/day)\n\n`;
  });
  
  return response;
}

function getAuthorOverview(allData, latestData) {
  const uniqueAuthors = new Set();
  let totalAuthorEntries = 0;
  
  for (const day of allData) {
    if (day.authors) {
      totalAuthorEntries += day.authors.length;
      day.authors.forEach(author => uniqueAuthors.add(author.author));
    }
  }
  
  let response = `ğŸ“ **Author Performance Overview**\n\n`;
  response += `ğŸ“Š **Stats:**\n`;
  response += `â€¢ Unique authors: ${uniqueAuthors.size}\n`;
  response += `â€¢ Total entries: ${totalAuthorEntries}\n\n`;
  
  if (latestData.authors && latestData.authors.length > 0) {
    response += `ğŸ“… **Yesterday's Top 3:**\n`;
    latestData.authors.slice(0, 3).forEach((author, i) => {
      response += `${i + 1}. ${author.author} - ${parseInt(author.users).toLocaleString()} users\n`;
    });
  }
  
  return response;
}

function handleKPIQueries(query, latestData, allData) {
  const date = latestData.date;
  const formattedDate = `${date.slice(4,6)}/${date.slice(6,8)}/${date.slice(0,4)}`;
  
  let response = `ğŸ“Š **Washington Examiner Analytics** (${formattedDate})\n\n`;
  
  response += `**Key Metrics:**\n`;
  response += `ğŸ‘¥ Total Users: ${parseInt(latestData.totalUsers || 0).toLocaleString()}\n`;
  response += `ğŸ†• New Users: ${parseInt(latestData.newUsers || 0).toLocaleString()}\n`;
  response += `ğŸ“„ Page Views: ${parseInt(latestData.pageviews || 0).toLocaleString()}\n`;
  response += `ğŸ”— Sessions: ${parseInt(latestData.sessions || 0).toLocaleString()}\n`;
  response += `â±ï¸ Avg Session: ${Math.round(parseFloat(latestData.averageSessionDuration || 0))}s\n`;
  response += `ğŸ“ˆ Bounce Rate: ${(parseFloat(latestData.bounceRate || 0) * 100).toFixed(1)}%\n\n`;
  
  if (allData.length > 1) {
    const previousDay = allData[allData.length - 2];
    const userChange = parseInt(latestData.totalUsers) - parseInt(previousDay.totalUsers || 0);
    const viewChange = parseInt(latestData.pageviews) - parseInt(previousDay.pageviews || 0);
    
    response += `**Day-over-Day Change:**\n`;
    response += `Users: ${userChange >= 0 ? '+' : ''}${userChange.toLocaleString()}\n`;
    response += `Views: ${viewChange >= 0 ? '+' : ''}${viewChange.toLocaleString()}\n`;
  }
  
  return response;
}

function handleTrafficQueries(query, latestData, allData) {
  if (!latestData.referrers || latestData.referrers.length === 0) {
    return "No traffic source data available.";
  }
  
  let response = `ğŸŒ **Traffic Sources** (Yesterday)\n\n`;
  
  latestData.referrers.forEach((referrer, index) => {
    const users = parseInt(referrer.users || 0);
    response += `${index + 1}. **${referrer.source}** - ${users.toLocaleString()} users\n`;
  });
  
  return response;
}

function handleTrendQueries(query, allData) {
  if (allData.length < 2) {
    return "Not enough data for trend analysis.";
  }
  
  let response = `ğŸ“ˆ **Trend Analysis** (7 days)\n\n`;
  
  response += `ğŸ“… **Daily Performance:**\n`;
  allData.slice(-7).forEach(day => {
    const date = `${day.date.slice(4,6)}/${day.date.slice(6,8)}`;
    const users = parseInt(day.totalUsers || 0);
    const views = parseInt(day.pageviews || 0);
    response += `${date}: ${users.toLocaleString()} users, ${views.toLocaleString()} views\n`;
  });
  
  return response;
}

function handleOverviewQuery(latestData, allData, data) {
  const date = `${latestData.date.slice(4,6)}/${latestData.date.slice(6,8)}`;
  
  let response = `ğŸ“Š **Washington Examiner Analytics Overview**\n\n`;
  response += `ğŸ“… **Latest Data:** ${date}\n`;
  response += `ğŸ‘¥ **Users:** ${parseInt(latestData.totalUsers || 0).toLocaleString()}\n`;
  response += `ğŸ“„ **Views:** ${parseInt(latestData.pageviews || 0).toLocaleString()}\n\n`;
  
  const authorCount = latestData.authors?.length || 0;
  const articleCount = latestData.articles?.length || 0;
  const sectionCount = latestData.sections?.length || 0;
  
  if (authorCount > 0) {
    response += `âœï¸ **Top Author:** ${latestData.authors[0].author}\n`;
  }
  if (articleCount > 0) {
    const topTitle = latestData.articles[0].title;
    const shortTitle = topTitle.length > 50 ? topTitle.substring(0, 47) + "..." : topTitle;
    response += `ğŸ“° **Top Article:** ${shortTitle}\n`;
  }
  if (sectionCount > 0) {
    response += `ğŸ“ **Top Section:** ${latestData.sections[0].section}\n`;
  }
  
  response += `\nğŸ’¬ **Try asking:**\n`;
  response += `â€¢ "Top stories yesterday"\n`;
  response += `â€¢ "Best performing sections"\n`;
  response += `â€¢ "Show me Lauren Green's performance"\n`;
  response += `â€¢ "What were yesterday's KPIs?"\n`;
  
  return response;
}
