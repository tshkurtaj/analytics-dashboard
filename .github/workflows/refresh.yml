name: Refresh GA4 (daily + manual)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "15 7 * * *"  # daily 07:15 UTC

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      GA4_PROPERTY_ID: ${{ secrets.GA4_PROPERTY_ID }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json
        run: |
          test -f package.json || npm init -y
          npm pkg set type=commonjs

      - name: Install deps
        run: npm i --no-fund --no-audit @google-analytics/data@^5.0.4

      - name: Decode GCP service account key
        run: |
          mkdir -p .secrets
          echo '${{ secrets.GCP_SA_JSON }}' | base64 -d > .secrets/gcp.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$PWD/.secrets/gcp.json" >> $GITHUB_ENV

      - name: Build GA4 JSON (Fixed Articles Collection)
        run: |
          mkdir -p scripts data
          cat > scripts/fetch_ga4.cjs <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { BetaAnalyticsDataClient } = require("@google-analytics/data");

          const propertyId = process.env.GA4_PROPERTY_ID;
          if (!propertyId) throw new Error("Missing GA4_PROPERTY_ID");
          const client = new BetaAnalyticsDataClient();

          const pad = n => String(n).padStart(2,"0");
          const ymd = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
          const yyyymmdd = d => `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}`;

          const now = new Date();
          const end = new Date(now); end.setDate(end.getDate()-1);
          const start = new Date(end); start.setDate(start.getDate()-6);

          const startISO = ymd(start);
          const endISO = ymd(end);
          const property = `properties/${propertyId}`;

          console.log(`[GA4] Fetching data ${startISO} ‚Üí ${endISO}`);

          async function runReport(config) {
            const [res] = await client.runReport({
              property,
              dateRanges: [{ startDate: startISO, endDate: endISO }],
              ...config
            });
            return res;
          }

          async function getDailyKPIs() {
            console.log('[KPI] Fetching daily KPIs...');
            const r = await runReport({
              dimensions: [{ name: "date" }],
              metrics: [
                { name: "totalUsers" },
                { name: "newUsers" },
                { name: "screenPageViews" },
                { name: "sessions" },
                { name: "bounceRate" },
                { name: "averageSessionDuration" }
              ]
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const m = row.metricValues;
              map[date] = {
                date,
                totalUsers: parseInt(m[0].value),
                newUsers: parseInt(m[1].value),
                pageviews: parseInt(m[2].value),
                sessions: parseInt(m[3].value),
                bounceRate: parseFloat(m[4].value),
                averageSessionDuration: parseFloat(m[5].value)
              };
            }
            console.log(`[KPI] Found ${Object.keys(map).length} days`);
            return map;
          }

          async function getReferrers() {
            console.log('[REF] Fetching referrers...');
            const r = await runReport({
              dimensions: [{ name: "date" }, { name: "firstUserSource" }],
              metrics: [{ name: "totalUsers" }],
              orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
              limit: 2000
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const source = row.dimensionValues[1].value;
              const users = parseInt(row.metricValues[0].value);
              
              if (!map[date]) map[date] = [];
              map[date].push({ source, users });
            }

            for (const date of Object.keys(map)) {
              map[date] = map[date].slice(0, 15);
            }
            
            console.log(`[REF] Found ${Object.keys(map).length} days`);
            return map;
          }

          async function getAuthors() {
            console.log('[AUTHORS] Fetching author data...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "customEvent:authors" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 5000
              });

              const map = {};
              let validEntries = 0;

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const author = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!author || author === "(not set)" || author.trim() === "" || users === 0) {
                  continue;
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  author: author.trim(), 
                  users: users.toString(), 
                  views: views.toString() 
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 10);
              }

              console.log(`[AUTHORS] Success! ${validEntries} entries across ${Object.keys(map).length} days`);
              return map;

            } catch (error) {
              console.log(`[AUTHORS] Error: ${error.message}`);
              return {};
            }
          }

          async function getTopArticles() {
            console.log('[ARTICLES] Fetching top articles using pageTitle...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "pageTitle" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 500
              });

              const map = {};
              let validEntries = 0;

              console.log(`[ARTICLES] Processing ${r.rows?.length || 0} page titles...`);

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const title = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!title || title === "(not set)" || title === "Home" || users < 50) {
                  continue;
                }

                let cleanTitle = title.trim();
                cleanTitle = cleanTitle.replace(/ - Washington Examiner$/, '');
                cleanTitle = cleanTitle.replace(/ \| Washington Examiner$/, '');
                
                if (cleanTitle.length > 120) {
                  cleanTitle = cleanTitle.substring(0, 117) + "...";
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  title: cleanTitle,
                  users: users.toString(), 
                  views: views.toString()
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 15);
              }

              console.log(`[ARTICLES] Success! ${validEntries} valid entries across ${Object.keys(map).length} days`);
              
              const allArticles = Object.values(map).flat();
              if (allArticles.length > 0) {
                const samples = allArticles.slice(0, 3).map(a => `${a.title.substring(0, 40)}... (${a.users})`);
                console.log(`[ARTICLES] Sample: ${samples.join(', ')}`);
              }
              
              return map;

            } catch (error) {
              console.log(`[ARTICLES] Error: ${error.message}`);
              return {};
            }
          }

          async function getSections() {
            console.log('[SECTIONS] Fetching section data...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "customEvent:section" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 1000
              });

              const map = {};
              let validEntries = 0;

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const section = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!section || section === "(not set)" || section.trim() === "" || users === 0) {
                  continue;
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  section: section.trim(), 
                  users: users.toString(), 
                  views: views.toString() 
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 10);
              }

              console.log(`[SECTIONS] Success! ${validEntries} entries across ${Object.keys(map).length} days`);
              return map;

            } catch (error) {
              console.log(`[SECTIONS] Error: ${error.message}`);
              return {};
            }
          }

          async function main() {
            try {
              const [kpis, referrers, authors, articles, sections] = await Promise.all([
                getDailyKPIs(),
                getReferrers(),
                getAuthors(),
                getTopArticles(),
                getSections()
              ]);

              const rows = [];
              for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                const dateKey = yyyymmdd(d);
                
                const dayData = {
                  date: dateKey,
                  totalUsers: kpis[dateKey]?.totalUsers || 0,
                  newUsers: kpis[dateKey]?.newUsers || 0,
                  pageviews: kpis[dateKey]?.pageviews || 0,
                  sessions: kpis[dateKey]?.sessions || 0,
                  bounceRate: kpis[dateKey]?.bounceRate || 0,
                  averageSessionDuration: kpis[dateKey]?.averageSessionDuration || 0,
                  referrers: referrers[dateKey] || [],
                  authors: authors[dateKey] || [],
                  articles: articles[dateKey] || [],
                  sections: sections[dateKey] || []
                };
                
                rows.push(dayData);
              }

              const totalAuthorEntries = rows.reduce((sum, row) => sum + row.authors.length, 0);
              const totalArticleEntries = rows.reduce((sum, row) => sum + row.articles.length, 0);
              const totalSectionEntries = rows.reduce((sum, row) => sum + row.sections.length, 0);
              
              const uniqueAuthors = new Set();
              const uniqueSections = new Set();
              rows.forEach(row => {
                row.authors.forEach(a => uniqueAuthors.add(a.author));
                row.sections.forEach(s => uniqueSections.add(s.section));
              });

              const output = {
                updatedAt: new Date().toISOString(),
                range: { start: startISO, end: endISO },
                rows,
                meta: {
                  totalDays: rows.length,
                  totalAuthorEntries,
                  totalArticleEntries,
                  totalSectionEntries,
                  uniqueAuthors: uniqueAuthors.size,
                  uniqueSections: uniqueSections.size,
                  sampleAuthors: Array.from(uniqueAuthors).slice(0, 5),
                  sampleSections: Array.from(uniqueSections).slice(0, 5)
                }
              };

              fs.writeFileSync(path.join("data", "ga4.json"), JSON.stringify(output, null, 2));
              
              console.log(`‚úÖ COMPREHENSIVE SUCCESS!`);
              console.log(`üìä ${rows.length} days collected`);
              console.log(`üë• Authors: ${totalAuthorEntries} entries, ${uniqueAuthors.size} unique`);
              console.log(`üì∞ Articles: ${totalArticleEntries} entries (from pageTitle)`);
              console.log(`üìÅ Sections: ${totalSectionEntries} entries, ${uniqueSections.size} unique`);

            } catch (error) {
              console.error('‚ùå Fatal error:', error);
              process.exit(1);
            }
          }

          main();
          NODE
          
          node scripts/fetch_ga4.cjs

      - name: Commit updated data
        run: |
          echo "Updating comprehensive GA4 data with fixed articles..."
          
          echo "File size: $(wc -c < data/ga4.json) bytes"
          echo "Content summary:"
          grep -c '"authors"' data/ga4.json || echo "No authors"
          grep -c '"articles"' data/ga4.json || echo "No articles"  
          grep -c '"sections"' data/ga4.json || echo "No sections"
          
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          
          if command -v jq >/dev/null 2>&1; then
            temp_file=$(mktemp)
            jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" '.updatedAt = $timestamp' data/ga4.json > "$temp_file"
            mv "$temp_file" data/ga4.json
          fi
          
          git add data/ga4.json
          git commit -m "data: fixed articles collection - authors, articles, sections ($(date '+%Y-%m-%d %H:%M:%S UTC'))" || echo "Nothing to commit"
          git push || echo "Nothing to push"
          
          echo "‚úÖ Update complete with fixed articles collection"
