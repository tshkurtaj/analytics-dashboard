name: Refresh GA4 (daily + manual)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "15 7 * * *"  # daily 07:15 UTC

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      GA4_PROPERTY_ID: ${{ secrets.GA4_PROPERTY_ID }}
      # Remove GOOGLE_SHEETS_ID since we'll use a public sheet or different approach

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create package.json
        run: |
          test -f package.json || npm init -y
          npm pkg set type=commonjs

      - name: Install deps
        run: npm i --no-fund --no-audit @google-analytics/data@^5.0.4

      - name: Decode GCP service account key
        run: |
          mkdir -p .secrets
          echo '${{ secrets.GCP_SA_JSON }}' | base64 -d > .secrets/gcp.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=$PWD/.secrets/gcp.json" >> $GITHUB_ENV

      - name: Build GA4 JSON (Fixed Articles Collection)
        run: |
          mkdir -p scripts data
          cat > scripts/fetch_ga4.cjs <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { BetaAnalyticsDataClient } = require("@google-analytics/data");

          const propertyId = process.env.GA4_PROPERTY_ID;
          if (!propertyId) throw new Error("Missing GA4_PROPERTY_ID");
          const client = new BetaAnalyticsDataClient();

          const pad = n => String(n).padStart(2,"0");
          const ymd = d => `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
          const yyyymmdd = d => `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}`;

          const now = new Date();
          const end = new Date(now); end.setDate(end.getDate()-1);
          const start = new Date(end); start.setDate(start.getDate()-6);

          const startISO = ymd(start);
          const endISO = ymd(end);
          const property = `properties/${propertyId}`;

          console.log(`[GA4] Fetching data ${startISO} â†’ ${endISO}`);

          async function runReport(config) {
            const [res] = await client.runReport({
              property,
              dateRanges: [{ startDate: startISO, endDate: endISO }],
              ...config
            });
            return res;
          }

          async function getDailyKPIs() {
            console.log('[KPI] Fetching daily KPIs...');
            const r = await runReport({
              dimensions: [{ name: "date" }],
              metrics: [
                { name: "totalUsers" },
                { name: "newUsers" },
                { name: "screenPageViews" },
                { name: "sessions" },
                { name: "bounceRate" },
                { name: "averageSessionDuration" }
              ]
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const m = row.metricValues;
              map[date] = {
                date,
                totalUsers: parseInt(m[0].value),
                newUsers: parseInt(m[1].value),
                pageviews: parseInt(m[2].value),
                sessions: parseInt(m[3].value),
                bounceRate: parseFloat(m[4].value),
                averageSessionDuration: parseFloat(m[5].value)
              };
            }
            console.log(`[KPI] Found ${Object.keys(map).length} days`);
            return map;
          }

          async function getReferrers() {
            console.log('[REF] Fetching referrers...');
            const r = await runReport({
              dimensions: [{ name: "date" }, { name: "firstUserSource" }],
              metrics: [{ name: "totalUsers" }],
              orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
              limit: 2000
            });

            const map = {};
            for (const row of r.rows || []) {
              const date = row.dimensionValues[0].value;
              const source = row.dimensionValues[1].value;
              const users = parseInt(row.metricValues[0].value);
              
              if (!map[date]) map[date] = [];
              map[date].push({ source, users });
            }

            for (const date of Object.keys(map)) {
              map[date] = map[date].slice(0, 15);
            }
            
            console.log(`[REF] Found ${Object.keys(map).length} days`);
            return map;
          }

          async function getAuthors() {
            console.log('[AUTHORS] Fetching author data...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "customEvent:authors" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 5000
              });

              const map = {};
              let validEntries = 0;

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const author = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!author || author === "(not set)" || author.trim() === "" || users === 0) {
                  continue;
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  author: author.trim(), 
                  users: users.toString(), 
                  views: views.toString() 
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 10);
              }

              console.log(`[AUTHORS] Success! ${validEntries} entries across ${Object.keys(map).length} days`);
              return map;

            } catch (error) {
              console.log(`[AUTHORS] Error: ${error.message}`);
              return {};
            }
          }

          async function getTopArticles() {
            console.log('[ARTICLES] Fetching top articles using pageTitle...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "pageTitle" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 500
              });

              const map = {};
              let validEntries = 0;

              console.log(`[ARTICLES] Processing ${r.rows?.length || 0} page titles...`);

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const title = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!title || title === "(not set)" || title === "Home" || users < 50) {
                  continue;
                }

                let cleanTitle = title.trim();
                cleanTitle = cleanTitle.replace(/ - Washington Examiner$/, '');
                cleanTitle = cleanTitle.replace(/ \| Washington Examiner$/, '');
                
                if (cleanTitle.length > 120) {
                  cleanTitle = cleanTitle.substring(0, 117) + "...";
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  title: cleanTitle,
                  users: users.toString(), 
                  views: views.toString()
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 15);
              }

              console.log(`[ARTICLES] Success! ${validEntries} valid entries across ${Object.keys(map).length} days`);
              
              const allArticles = Object.values(map).flat();
              if (allArticles.length > 0) {
                const samples = allArticles.slice(0, 3).map(a => `${a.title.substring(0, 40)}... (${a.users})`);
                console.log(`[ARTICLES] Sample: ${samples.join(', ')}`);
              }
              
              return map;

            } catch (error) {
              console.log(`[ARTICLES] Error: ${error.message}`);
              return {};
            }
          }

          async function getSections() {
            console.log('[SECTIONS] Fetching section data...');
            
            try {
              const r = await runReport({
                dimensions: [{ name: "date" }, { name: "customEvent:section" }],
                metrics: [{ name: "totalUsers" }, { name: "screenPageViews" }],
                orderBys: [{ metric: { metricName: "totalUsers" }, desc: true }],
                limit: 1000
              });

              const map = {};
              let validEntries = 0;

              for (const row of r.rows || []) {
                const date = row.dimensionValues[0].value;
                const section = row.dimensionValues[1].value;
                const users = parseInt(row.metricValues[0].value);
                const views = parseInt(row.metricValues[1].value);

                if (!section || section === "(not set)" || section.trim() === "" || users === 0) {
                  continue;
                }

                if (!map[date]) map[date] = [];
                map[date].push({ 
                  section: section.trim(), 
                  users: users.toString(), 
                  views: views.toString() 
                });
                validEntries++;
              }

              for (const date of Object.keys(map)) {
                map[date].sort((a, b) => parseInt(b.users) - parseInt(a.users));
                map[date] = map[date].slice(0, 10);
              }

              console.log(`[SECTIONS] Success! ${validEntries} entries across ${Object.keys(map).length} days`);
              return map;

            } catch (error) {
              console.log(`[SECTIONS] Error: ${error.message}`);
              return {};
            }
          }

          async function main() {
            try {
              const [kpis, referrers, authors, articles, sections] = await Promise.all([
                getDailyKPIs(),
                getReferrers(),
                getAuthors(),
                getTopArticles(),
                getSections()
              ]);

              const rows = [];
              for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                const dateKey = yyyymmdd(d);
                
                const dayData = {
                  date: dateKey,
                  totalUsers: kpis[dateKey]?.totalUsers || 0,
                  newUsers: kpis[dateKey]?.newUsers || 0,
                  pageviews: kpis[dateKey]?.pageviews || 0,
                  sessions: kpis[dateKey]?.sessions || 0,
                  bounceRate: kpis[dateKey]?.bounceRate || 0,
                  averageSessionDuration: kpis[dateKey]?.averageSessionDuration || 0,
                  referrers: referrers[dateKey] || [],
                  authors: authors[dateKey] || [],
                  articles: articles[dateKey] || [],
                  sections: sections[dateKey] || []
                };
                
                rows.push(dayData);
              }

              const totalAuthorEntries = rows.reduce((sum, row) => sum + row.authors.length, 0);
              const totalArticleEntries = rows.reduce((sum, row) => sum + row.articles.length, 0);
              const totalSectionEntries = rows.reduce((sum, row) => sum + row.sections.length, 0);
              
              const uniqueAuthors = new Set();
              const uniqueSections = new Set();
              rows.forEach(row => {
                row.authors.forEach(a => uniqueAuthors.add(a.author));
                row.sections.forEach(s => uniqueSections.add(s.section));
              });

              const output = {
                updatedAt: new Date().toISOString(),
                range: { start: startISO, end: endISO },
                rows,
                meta: {
                  totalDays: rows.length,
                  totalAuthorEntries,
                  totalArticleEntries,
                  totalSectionEntries,
                  uniqueAuthors: uniqueAuthors.size,
                  uniqueSections: uniqueSections.size,
                  sampleAuthors: Array.from(uniqueAuthors).slice(0, 5),
                  sampleSections: Array.from(uniqueSections).slice(0, 5)
                }
              };

              fs.writeFileSync(path.join("data", "ga4.json"), JSON.stringify(output, null, 2));
              
              console.log(`âœ… GA4 SUCCESS!`);
              console.log(`ðŸ“Š ${rows.length} days collected`);
              console.log(`ðŸ‘¥ Authors: ${totalAuthorEntries} entries, ${uniqueAuthors.size} unique`);
              console.log(`ðŸ“° Articles: ${totalArticleEntries} entries (from pageTitle)`);
              console.log(`ðŸ“ Sections: ${totalSectionEntries} entries, ${uniqueSections.size} unique`);

            } catch (error) {
              console.error('âŒ Fatal error:', error);
              process.exit(1);
            }
          }

          main();
          NODE
          
          node scripts/fetch_ga4.cjs

      - name: Create Mock Production Data (Since Sheets is Private)
        run: |
          cat > scripts/create_mock_sheets.cjs <<'NODE'
          const fs = require("fs");
          const path = require("path");

          console.log('[MOCK SHEETS] Creating sample production data...');

          // Create realistic mock production data
          const authors = [
            'Jenny Goldsberry', 'Asher Notheis', 'Molly Prince', 'Lauren Irwin',
            'Ross Muscato', 'Sarah Bedford', 'Bethany Blankley', 'Washington Examiner',
            'Kerry Picket', 'Gabe Kaminsky', 'Joseph Clark', 'Susan Ferrechio'
          ];

          const sections = [
            'News', 'Politics', 'Policy', 'Opinion', 'Restoring America',
            'Washington Secrets', 'Beltway Confidential', 'Business', 'Sports',
            'Magazine', 'Local', 'International'
          ];

          const now = new Date();
          const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
          
          const dailyProduction = {};
          const authorProduction = {};
          const sectionProduction = {};
          
          let totalArticles = 0;

          // Generate realistic daily production data
          for (let d = new Date(thirtyDaysAgo); d <= now; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            const isWeekend = d.getDay() === 0 || d.getDay() === 6;
            
            // Fewer articles on weekends
            const articlesPerDay = isWeekend ? Math.floor(Math.random() * 8) + 2 : Math.floor(Math.random() * 15) + 8;
            
            dailyProduction[dateStr] = {
              date: dateStr,
              totalArticles: articlesPerDay,
              authors: {},
              sections: {}
            };
            
            totalArticles += articlesPerDay;
            
            // Distribute articles among authors
            for (let i = 0; i < articlesPerDay; i++) {
              const author = authors[Math.floor(Math.random() * authors.length)];
              const section = sections[Math.floor(Math.random() * sections.length)];
              
              // Update daily tracking
              dailyProduction[dateStr].authors[author] = (dailyProduction[dateStr].authors[author] || 0) + 1;
              dailyProduction[dateStr].sections[section] = (dailyProduction[dateStr].sections[section] || 0) + 1;
              
              // Update overall tracking
              authorProduction[author] = (authorProduction[author] || 0) + 1;
              sectionProduction[section] = (sectionProduction[section] || 0) + 1;
            }
          }

          const productionData = {
            updatedAt: new Date().toISOString(),
            totalArticles: totalArticles,
            dateRange: {
              start: thirtyDaysAgo.toISOString().split('T')[0],
              end: now.toISOString().split('T')[0]
            },
            dailyProduction: Object.values(dailyProduction).sort((a, b) => a.date.localeCompare(b.date)),
            topAuthors: Object.entries(authorProduction)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 20)
              .map(([author, count]) => ({ author, articles: count })),
            topSections: Object.entries(sectionProduction)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 15)
              .map(([section, count]) => ({ section, articles: count }))
          };

          fs.writeFileSync(path.join("data", "sheets.json"), JSON.stringify(productionData, null, 2));
          console.log(`[MOCK SHEETS] âœ… SUCCESS! Generated ${totalArticles} articles, ${Object.keys(authorProduction).length} authors, ${Object.keys(sectionProduction).length} sections`);

          NODE
          
          node scripts/create_mock_sheets.cjs

      - name: Commit updated data
        run: |
          echo "Updating comprehensive data - GA4 + Mock Production..."
          
          echo "GA4 file size: $(wc -c < data/ga4.json) bytes"
          echo "Sheets file size: $(wc -c < data/sheets.json) bytes"
          
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          
          git add data/ga4.json data/sheets.json
          git commit -m "data: comprehensive update - GA4 performance + mock production ($(date '+%Y-%m-%d %H:%M:%S UTC'))" || echo "Nothing to commit"
          git push || echo "Nothing to push"
          
          echo "âœ… Update complete - both GA4 and mock production data"
